---
import { getCollection } from "astro:content";
import { slugify } from "@/utils/strings.ts";
import { formatDateInterval } from "@/utils/date.ts";
import { siteSettings } from "@/site.config.ts";

// Get highlighted entries from both collections (build-time data)
const events = await getCollection("events", ({ data }) => 
    (data.createBanner ? data.createBanner : false) && (typeof data.visible === "boolean" ? data.visible : true));

const news = await getCollection("news", ({ data }) => 
    (data.createBanner ? data.createBanner : false) && (typeof data.visible === "boolean" ? data.visible : true));

const alerts = await getCollection("alerts", ({ data }) => 
    (typeof data.visible === "boolean" ? data.visible : true) );
    
// Combine and sort by date (newest first)
const bannerEventItems = events
    .map(event => ({
        id: event.id,
        title: event.data.name,
        type: "event",
        eventDates: Array.isArray(event.data.date) ? event.data.date : [event.data.date],
        date: new Date(Array.isArray(event.data.date) ? event.data.date.reverse()[0] : event.data.date),
        autoHide: event.data.autoHideBanner || false,
        url: `/events/${slugify(event.data.group)}/${slugify(event.data.name)}`
    }))

const bannerNewsItems = news
    .map(newi => ({
        id: newi.id,
        title: newi.data.title,
        type: "news",
        date: (() => {
            const publishDate = new Date(newi.data.date);
            const afterMs = typeof newi.data.autoHideBannerAfter === "number" ? newi.data.autoHideBannerAfter : 30 * 24 * 60 * 60 * 1000;
            return new Date(publishDate.getTime() + afterMs);
        })(),
        autoHide: newi.data.autoHideBanner || false,
        url: `/news/${newi.id}`
    }))

const bannerAlerts = alerts
    .map(alert => ({
        id: alert.id,
        title: alert.data.message,
        type: alert.data.label || "alert",
        date: alert.data.autoHideBannerOn ? new Date(alert.data.autoHideBannerOn) : new Date((new Date()).getTime() + 48 * 60 * 60 * 1000), // Use autoHideBannerOn or default to 48 hours from now
        autoHide: alert.data.autoHideBanner || false,
        url: alert.data.url || null
    }))

// Pass all items to client-side for dynamic filtering
const allBannerItems = [...bannerEventItems, ...bannerNewsItems, ...bannerAlerts];
---

<!-- Always render banner container, let client-side decide visibility -->
<div id="banner" class="h-8 py-1 w-100vw relative bg-red-800 dark:bg-gray-300 text-white dark:text-gray-900 hidden">
    <div class="w-100lvw px-4 h-full">
        <div class="flex w-full items-center justify-between h-full">
            <!-- Left: Pagination Dots -->
            <div class="flex items-center w-16">
                <div id="banner-dots" class="flex gap-1">
                    <!-- Dots will be generated by JavaScript -->
                </div>
            </div>
            
            <!-- Center: Content Area -->
            <div class="flex-1 relative h-full flex items-center justify-center">
                <div id="banner-content">
                    <!-- Content will be generated by JavaScript -->
                </div>
            </div>
            
            <!-- Right: Close Button -->
            <div class="flex items-center justify-end w-16">
                <button 
                    id="banner-close" 
                    class="flex-shrink-0 w-6 h-6 flex items-center justify-center hover:bg-white/20 rounded transition-colors"
                    aria-label="Close banner"
                >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Pass data to JavaScript -->
<script define:vars={{ bannerItems: allBannerItems, reopenBannerAfter: siteSettings.reopenBannerAfter }}>
    window.BANNER_ITEMS = bannerItems;
    window.REOPEN_BANNER_AFTER = reopenBannerAfter;
</script>

<script>
    const delay = 3000;

    function filterBannerItems() {
        const today = new Date();
        
        return window.BANNER_ITEMS.filter(item => {
            let eventDate;
            if (Array.isArray(item.date)) {
                // If date is an array, use the last date in the array
                eventDate = new Date(item.date.reverse()[0]);
            } else if (typeof item.date === 'string') {
                // If date is a string, parse it
                eventDate = new Date(item.date);
            } else if (!(item.date instanceof Date)) {
                // If date is not a valid Date object, skip this item
                return false;
            }
            const itemDate = new Date(eventDate.getTime() + 24 * 60 * 60 * 1000); // Add one day to the date to include the whole day
            return item.autoHide === false || (item.autoHide === true && itemDate >= today); // Only show items that are today or in the future if autoHide is false
        });
    }

    function formatDateInterval(dates: Date[] | string[]): string {
        if (!Array.isArray(dates) || dates.length === 0) return "";

        // Convert to Date objects if needed
        const toDate = (d: Date | string) => d instanceof Date ? d : new Date(d);
        const sortedDates = [...dates].sort((a, b) => new Date(a) - new Date(b));
        const [start, end] = [toDate(sortedDates[0]), dates.length > 1 ? toDate(sortedDates[1]) : null];

        const pad = (n: number) => n.toString().padStart(2, "0");

        if (dates.length === 1 || !end) {
            return `${pad(start.getDate())}/${pad(start.getMonth() + 1)}/${start.getFullYear()}`;
        }

        // If years differ, show full for both
        if (start.getFullYear() !== end.getFullYear()) {
            return `${pad(start.getDate())}/${pad(start.getMonth() + 1)}/${start.getFullYear()} – ${pad(end.getDate())}/${pad(end.getMonth() + 1)}/${end.getFullYear()}`;
        }
        // If months differ, show month for both, year once
        if (start.getMonth() !== end.getMonth()) {
            return `${pad(start.getDate())}/${pad(start.getMonth() + 1)} – ${pad(end.getDate())}/${pad(end.getMonth() + 1)}/${end.getFullYear()}`;
        }
        // Same month and year, show day-day/month/year
        return `${pad(start.getDate())} – ${pad(end.getDate())}/${pad(end.getMonth() + 1)}/${end.getFullYear()}`;
    }

    function generateBannerContent(filteredItems) {
        const bannerContent = document.getElementById('banner-content');
        const bannerDots = document.getElementById('banner-dots');
        
        if (!bannerContent || !bannerDots) return;

        // Generate content items
        bannerContent.innerHTML = filteredItems.map((item, index) => `
            <div 
                class="banner-item absolute inset-0 flex items-center justify-center transition-opacity duration-500 ${index === 0 ? 'opacity-100' : 'opacity-0'}"
                data-index="${index}"
                style="z-index:1"
            >
                <div class="flex items-center gap-3">
                    <!-- Type Badge -->
                    <span class="px-2 py-1 bg-white/20 dark:bg-white rounded text-xs font-medium uppercase tracking-wide flex-shrink-0">
                        ${item.type.toUpperCase()}
                    </span>
                    <!-- Content -->
                    <div class="flex py-1 items-center">
                        ${item.url ? `
                            <a href="${item.url}" class="hover:underline block">
                                <div class="text-xs md:text-sm whitespace-nowrap">
                                    ${item.title}
                                </div>
                            </a>
                        ` : `
                            <div>
                                <div class="text-xs md:text-sm whitespace-nowrap">
                                    ${item.title}
                                </div>
                            </div>
                        `}
                    </div>
                    ${item.eventDates && item.eventDates.length > 0 ? `
                        <span class="px-2 py-1 bg-white/10 dark:bg-white rounded text-xs font-medium uppercase tracking-wide flex-shrink-0">
                            ${formatDateInterval(item.eventDates)}
                        </span>
                        ` : ''}
                </div>
            </div>
        `).join('');

        // Generate dots if multiple items
        if (filteredItems.length > 1) {
            bannerDots.innerHTML = filteredItems.map((_, index) => `
                <button 
                    class="w-2 h-2 rounded-full transition-all duration-300 ${index === 0 ? 'bg-white dark:bg-black' : 'bg-white/50 dark:bg-black/25'}"
                    data-dot="${index}"
                    aria-label="Go to banner item ${index + 1}"
                ></button>
            `).join('');
        } else {
            bannerDots.innerHTML = '';
        }
    }

    function initBanner() {
        const banner = document.getElementById('banner');
        const closeButton = document.getElementById('banner-close');
        
        if (!banner || !window.BANNER_ITEMS) return;

        // Check if banner was manually closed and if 30 minutes have passed
        const bannerClosedTime = localStorage.getItem('banner-closed-time');
        if (bannerClosedTime) {
            const closedTime = parseInt(bannerClosedTime);
            const reinitTime = (window.REOPEN_BANNER_AFTER || 30) * 60 * 1000; // use the value from settings or default to 30 minutes (in milliseconds)
            
            if (currentTime - closedTime < reinitTime) {
                banner.classList.add('hidden');
                return;
            } else {
                // 30 minutes have passed, remove the closed flag
                localStorage.removeItem('banner-closed-time');
            }
        }

        // Filter items based on current date
        const filteredItems = filterBannerItems();
        
        // Hide banner if no valid items
        if (filteredItems.length === 0) {
            banner.classList.add('hidden');
            return;
        }

        // Generate content and show banner
        generateBannerContent(filteredItems);
        banner.classList.remove('hidden');
        
        const bannerItems = document.querySelectorAll('.banner-item');
        const dots = document.querySelectorAll('[data-dot]');
        
        let currentIndex = 0;
        let rotationInterval;
        
        // Close banner functionality
        closeButton?.addEventListener('click', function() {
            banner.style.transform = 'translateY(-100%)';
            setTimeout(() => {
                banner.classList.add('hidden');
                banner.style.transform = '';
            }, 300);
            localStorage.setItem('banner-closed-time', Date.now().toString());
            if (rotationInterval) {
                clearInterval(rotationInterval);
            }
        });
        
        function showItem(index) {
            // Update opacity only - no layout changes
            bannerItems.forEach((item, i) => {
                if (i === index) {
                    item.classList.remove('opacity-0');
                    item.classList.add('opacity-100');
                } else {
                    item.classList.remove('opacity-100');
                    item.classList.add('opacity-0');
                }
            });

            // Update dots
            dots.forEach((dot, i) => {
                if (i === index) {
                    dot.classList.remove('bg-white/50', 'dark:bg-black/25');
                    dot.classList.add('bg-white', 'dark:bg-black');
                } else {
                    dot.classList.remove('bg-white', 'dark:bg-black');
                    dot.classList.add('bg-white/50', 'dark:bg-black/25');
                }
            });

            currentIndex = index;
        }
        
        function nextItem() {
            const next = (currentIndex + 1) % bannerItems.length;
            showItem(next);
        }

        // Only setup rotation if there are multiple items
        if (bannerItems.length > 1) {
            // Dot click handlers
            dots.forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    showItem(index);
                    // Reset interval
                    if (rotationInterval) {
                        clearInterval(rotationInterval);
                    }
                    rotationInterval = setInterval(nextItem, delay);
                });
            });
            
            // Start automatic rotation
            rotationInterval = setInterval(nextItem, delay);
            
            // Pause rotation on hover
            banner.addEventListener('mouseenter', () => {
                if (rotationInterval) {
                    clearInterval(rotationInterval);
                }
            });
            
            banner.addEventListener('mouseleave', () => {
                rotationInterval = setInterval(nextItem, delay);
            });
        }
        
        // Store interval reference for cleanup
        banner._rotationInterval = rotationInterval;
    }
    
    // Initialize on both page load events
    document.addEventListener('DOMContentLoaded', initBanner);
    document.addEventListener('astro:page-load', initBanner);
    
    // Cleanup on page navigation
    document.addEventListener('astro:before-preparation', () => {
        const banner = document.getElementById('banner');
        if (banner && banner._rotationInterval) {
            clearInterval(banner._rotationInterval);
        }
    });

    // Re-check banner every 30 minutes for date changes
    setInterval(initBanner, 30 * 60 * 1000);

    // Debug functions (optional)
    window.resetBanner = () => {
        localStorage.removeItem('banner-closed-time');
        initBanner();
    };
</script>

<style>
    #banner {
        transition: transform 0.3s ease-out;
    }
    
    .banner-item {
        transition: opacity 0.5s ease-in-out;
    }
    .banner-item.opacity-0 {
        pointer-events: none;
    }
    .banner-item.opacity-100 {
        pointer-events: auto;
    }
</style>